<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Generative AI Learning Studio</title>
    <style>
      @import url("https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap");

      :root {
        color-scheme: light dark;
        --bg: #0f172a;
        --bg-muted: rgba(15, 23, 42, 0.6);
        --surface: rgba(15, 23, 42, 0.4);
        --surface-light: #ffffff;
        --surface-dark: rgba(255, 255, 255, 0.08);
        --text: #e2e8f0;
        --text-muted: #94a3b8;
        --accent: #38bdf8;
        --accent-soft: rgba(56, 189, 248, 0.18);
        --accent-strong: #0ea5e9;
        --shadow: 0 24px 48px rgba(15, 23, 42, 0.35);
        --radius-lg: 24px;
        --radius-md: 18px;
        --radius-sm: 12px;
        --border: rgba(148, 163, 184, 0.2);
        --success: #34d399;
        --warning: #fbbf24;
        --danger: #f87171;
      }

      ::selection {
        background: rgba(56, 189, 248, 0.35);
        color: #0f172a;
      }

      body {
        margin: 0;
        font-family: "Inter", system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI",
          sans-serif;
        background: radial-gradient(circle at top left, rgba(56, 189, 248, 0.45), transparent 55%),
          radial-gradient(circle at bottom right, rgba(244, 114, 182, 0.25), transparent 45%),
          var(--bg);
        color: var(--text);
        min-height: 100vh;
        padding: 0 24px 120px;
        line-height: 1.6;
        position: relative;
        overflow-x: hidden;
      }

      body::before {
        content: "";
        position: fixed;
        inset: -40vh -40vw;
        background: radial-gradient(circle, rgba(56, 189, 248, 0.12), transparent 70%);
        filter: blur(60px);
        z-index: -2;
      }

      header {
        margin: 42px auto 36px;
        max-width: 1100px;
        padding: 32px clamp(24px, 4vw, 48px);
        border-radius: var(--radius-lg);
        background: linear-gradient(135deg, rgba(15, 23, 42, 0.8), rgba(15, 23, 42, 0.6));
        backdrop-filter: blur(18px);
        border: 1px solid rgba(148, 163, 184, 0.15);
        box-shadow: var(--shadow);
        position: relative;
        overflow: hidden;
      }

      header::after {
        content: "";
        position: absolute;
        inset: 0;
        background: radial-gradient(circle at 15% 20%, rgba(56, 189, 248, 0.4), transparent 55%),
          radial-gradient(circle at 85% 25%, rgba(244, 114, 182, 0.35), transparent 60%),
          radial-gradient(circle at 60% 80%, rgba(56, 189, 248, 0.25), transparent 65%);
        opacity: 0.6;
        pointer-events: none;
      }

      header > * {
        position: relative;
        z-index: 1;
      }

      header h1 {
        margin: 0 0 18px;
        font-size: clamp(2.6rem, 5vw, 3rem);
        font-weight: 700;
        letter-spacing: -0.02em;
      }

      header p {
        margin: 0 0 28px;
        max-width: 720px;
        font-size: 1.05rem;
        color: var(--text-muted);
      }

      .hero-stats {
        display: flex;
        gap: 18px;
        flex-wrap: wrap;
      }

      .stat-card {
        flex: 1 1 190px;
        min-width: 190px;
        padding: 18px;
        border-radius: var(--radius-md);
        background: linear-gradient(145deg, rgba(15, 23, 42, 0.82), rgba(15, 23, 42, 0.55));
        border: 1px solid rgba(148, 163, 184, 0.18);
        box-shadow: inset 0 0 0 1px rgba(56, 189, 248, 0.1);
      }

      .stat-card strong {
        display: block;
        font-size: 1.15rem;
        margin-bottom: 4px;
      }

      .stat-card span {
        color: var(--text-muted);
        font-size: 0.92rem;
      }

      main {
        max-width: 1100px;
        margin: 0 auto;
        position: relative;
      }

      .module-nav {
        position: sticky;
        top: 18px;
        display: flex;
        gap: 12px;
        flex-wrap: wrap;
        padding: 12px 18px;
        margin-bottom: 36px;
        border-radius: var(--radius-md);
        background: rgba(15, 23, 42, 0.72);
        border: 1px solid rgba(148, 163, 184, 0.18);
        backdrop-filter: blur(12px);
        z-index: 5;
      }

      .module-nav button {
        appearance: none;
        border: 1px solid rgba(148, 163, 184, 0.2);
        border-radius: 999px;
        padding: 10px 18px;
        font-size: 0.92rem;
        background: rgba(15, 23, 42, 0.6);
        color: var(--text);
        cursor: pointer;
        transition: all 0.3s ease;
      }

      .module-nav button:hover,
      .module-nav button:focus {
        outline: none;
        background: rgba(56, 189, 248, 0.2);
        border-color: rgba(56, 189, 248, 0.4);
        box-shadow: 0 0 0 4px rgba(56, 189, 248, 0.14);
      }

      .module-nav button.active {
        background: var(--accent);
        color: #0f172a;
        border-color: transparent;
      }

      section.module {
        margin-bottom: 72px;
        padding: clamp(24px, 4vw, 42px);
        border-radius: var(--radius-lg);
        background: linear-gradient(130deg, rgba(15, 23, 42, 0.82), rgba(15, 23, 42, 0.62));
        border: 1px solid rgba(148, 163, 184, 0.2);
        box-shadow: 0 28px 60px rgba(15, 23, 42, 0.45);
        backdrop-filter: blur(16px);
        position: relative;
      }

      section.module::after {
        content: "";
        position: absolute;
        inset: 0;
        border-radius: inherit;
        background: linear-gradient(140deg, rgba(56, 189, 248, 0.15), transparent 55%);
        pointer-events: none;
      }

      section.module > * {
        position: relative;
        z-index: 1;
      }

      section.module h2 {
        font-size: clamp(2rem, 4vw, 2.4rem);
        margin-top: 0;
        margin-bottom: 16px;
        letter-spacing: -0.01em;
      }

      .module-intro {
        margin-bottom: 28px;
        color: var(--text-muted);
        max-width: 780px;
      }

      .module-grid {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
        gap: 24px;
        align-items: start;
      }

      .panel {
        background: rgba(15, 23, 42, 0.65);
        border: 1px solid rgba(148, 163, 184, 0.16);
        border-radius: var(--radius-md);
        padding: 24px;
        position: relative;
        overflow: hidden;
      }

      .panel::before {
        content: "";
        position: absolute;
        inset: 0;
        background: linear-gradient(160deg, rgba(56, 189, 248, 0.12), transparent 70%);
        opacity: 0.8;
        pointer-events: none;
      }

      .panel > * {
        position: relative;
        z-index: 1;
      }

      .panel h3 {
        margin-top: 0;
        margin-bottom: 12px;
        font-size: 1.2rem;
      }

      .pill-group {
        display: flex;
        flex-wrap: wrap;
        gap: 10px;
        margin: 16px 0 24px;
      }

      .pill {
        padding: 9px 16px;
        border-radius: 999px;
        border: 1px solid rgba(148, 163, 184, 0.25);
        background: rgba(15, 23, 42, 0.55);
        color: var(--text);
        font-size: 0.9rem;
        cursor: pointer;
        transition: all 0.3s ease;
      }

      .pill.active {
        background: var(--accent);
        color: #0f172a;
        border-color: transparent;
        box-shadow: 0 6px 16px rgba(56, 189, 248, 0.35);
      }

      .architecture-diagram {
        margin: 18px 0 22px;
        border-radius: var(--radius-sm);
        background: rgba(15, 23, 42, 0.55);
        border: 1px solid rgba(148, 163, 184, 0.16);
        padding: 18px;
      }

      .architecture-diagram svg {
        width: 100%;
        height: auto;
      }

      .list-grid {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
        gap: 18px;
      }

      ul {
        list-style: none;
        padding: 0;
        margin: 0;
      }

      ul li {
        padding: 10px 12px;
        margin-bottom: 8px;
        border-radius: 12px;
        background: rgba(15, 23, 42, 0.5);
        border: 1px solid rgba(148, 163, 184, 0.12);
        display: flex;
        gap: 10px;
        align-items: flex-start;
      }

      ul li::before {
        content: "";
        flex: 0 0 10px;
        height: 10px;
        border-radius: 999px;
        margin-top: 6px;
        background: linear-gradient(135deg, var(--accent), rgba(56, 189, 248, 0.2));
      }

      .stat-bars {
        margin-top: 24px;
        display: grid;
        gap: 12px;
      }

      .stat-bar {
        display: flex;
        flex-direction: column;
        gap: 6px;
      }

      .stat-bar span {
        font-size: 0.85rem;
        color: var(--text-muted);
      }

      .bar-track {
        height: 12px;
        border-radius: 999px;
        background: rgba(148, 163, 184, 0.2);
        overflow: hidden;
      }

      .bar-fill {
        height: 100%;
        border-radius: inherit;
        background: linear-gradient(90deg, rgba(56, 189, 248, 0.7), rgba(129, 140, 248, 0.9));
        width: 0%;
        transition: width 0.5s ease;
      }

      .matrix {
        border-collapse: collapse;
        width: 100%;
        margin-top: 18px;
      }

      .matrix th,
      .matrix td {
        border: 1px solid rgba(148, 163, 184, 0.2);
        padding: 12px;
        text-align: left;
        font-size: 0.9rem;
      }

      .matrix th {
        background: rgba(15, 23, 42, 0.7);
      }

      .matrix td.highlight {
        background: rgba(56, 189, 248, 0.18);
        color: var(--text);
        font-weight: 600;
      }

      .range-wrapper {
        margin: 16px 0 12px;
        position: relative;
      }

      input[type="range"] {
        width: 100%;
        appearance: none;
        height: 6px;
        border-radius: 999px;
        background: rgba(148, 163, 184, 0.3);
        outline: none;
      }

      input[type="range"]::-webkit-slider-thumb {
        appearance: none;
        width: 22px;
        height: 22px;
        border-radius: 50%;
        background: var(--accent);
        border: 3px solid rgba(15, 23, 42, 0.85);
        box-shadow: 0 6px 16px rgba(56, 189, 248, 0.35);
        cursor: pointer;
      }

      input[type="range"]::-moz-range-thumb {
        width: 22px;
        height: 22px;
        border-radius: 50%;
        background: var(--accent);
        border: 3px solid rgba(15, 23, 42, 0.85);
        box-shadow: 0 6px 16px rgba(56, 189, 248, 0.35);
        cursor: pointer;
      }

      .range-labels {
        display: flex;
        justify-content: space-between;
        font-size: 0.8rem;
        color: var(--text-muted);
        margin-top: 8px;
      }

      .method-cards {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
        gap: 18px;
        margin-top: 22px;
      }

      .method-card {
        background: rgba(15, 23, 42, 0.55);
        border-radius: var(--radius-sm);
        padding: 18px;
        border: 1px solid rgba(148, 163, 184, 0.16);
        transition: transform 0.35s ease, border-color 0.35s ease, box-shadow 0.35s ease;
      }

      .method-card.active {
        border-color: rgba(56, 189, 248, 0.55);
        box-shadow: 0 16px 32px rgba(56, 189, 248, 0.25);
        transform: translateY(-6px);
      }

      .method-card h4 {
        margin: 0 0 10px;
        font-size: 1rem;
      }

      .method-card p {
        margin: 0;
        font-size: 0.9rem;
        color: var(--text-muted);
      }

      .method-card .badge {
        display: inline-flex;
        align-items: center;
        gap: 6px;
        padding: 4px 10px;
        border-radius: 999px;
        background: rgba(56, 189, 248, 0.2);
        color: var(--accent);
        font-size: 0.75rem;
        margin-bottom: 10px;
      }

      .diagram-grid {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
        gap: 20px;
        margin-top: 24px;
      }

      .diagram-card {
        border-radius: var(--radius-sm);
        border: 1px solid rgba(148, 163, 184, 0.2);
        background: rgba(15, 23, 42, 0.6);
        padding: 18px;
      }

      .diagram-card svg {
        width: 100%;
        height: auto;
      }

      .rag-comparison {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
        gap: 24px;
        margin-top: 18px;
      }

      .rag-column {
        border-radius: var(--radius-md);
        padding: 22px;
        border: 1px solid rgba(148, 163, 184, 0.18);
        background: rgba(15, 23, 42, 0.6);
        position: relative;
      }

      .rag-column::before {
        content: attr(data-label);
        position: absolute;
        top: -14px;
        left: 22px;
        padding: 6px 12px;
        background: rgba(15, 23, 42, 0.9);
        border-radius: 999px;
        border: 1px solid rgba(148, 163, 184, 0.22);
        font-size: 0.75rem;
        letter-spacing: 0.08em;
        text-transform: uppercase;
        color: var(--text-muted);
      }

      .rag-steps {
        list-style: none;
        padding: 0;
        margin: 0;
        display: grid;
        gap: 14px;
      }

      .rag-steps li {
        padding: 12px 14px 12px 44px;
        border-radius: var(--radius-sm);
        border: 1px solid rgba(148, 163, 184, 0.18);
        background: rgba(15, 23, 42, 0.5);
        position: relative;
        cursor: pointer;
        transition: transform 0.3s ease, border-color 0.3s ease, box-shadow 0.3s ease;
      }

      .rag-steps li::before {
        content: attr(data-step);
        position: absolute;
        left: 14px;
        top: 12px;
        width: 22px;
        height: 22px;
        border-radius: 50%;
        background: rgba(56, 189, 248, 0.18);
        border: 1px solid rgba(56, 189, 248, 0.45);
        display: grid;
        place-items: center;
        font-size: 0.75rem;
        color: var(--accent);
      }

      .rag-steps li.active {
        border-color: rgba(56, 189, 248, 0.55);
        box-shadow: 0 12px 24px rgba(56, 189, 248, 0.25);
        transform: translateX(6px);
        background: rgba(56, 189, 248, 0.22);
        color: var(--text);
      }

      .rag-visual svg {
        width: 100%;
        height: auto;
      }

      .rag-controls {
        margin-top: 24px;
        display: flex;
        flex-wrap: wrap;
        gap: 12px;
        align-items: center;
        justify-content: space-between;
      }

      .rag-controls button {
        padding: 10px 18px;
        border-radius: 999px;
        border: none;
        background: var(--accent);
        color: #0f172a;
        font-weight: 600;
        cursor: pointer;
        display: inline-flex;
        align-items: center;
        gap: 8px;
        transition: transform 0.2s ease, box-shadow 0.2s ease;
      }

      .rag-controls button:hover {
        transform: translateY(-2px);
        box-shadow: 0 12px 24px rgba(56, 189, 248, 0.28);
      }

      .legend {
        display: flex;
        gap: 12px;
        flex-wrap: wrap;
        font-size: 0.8rem;
        color: var(--text-muted);
      }

      .legend span {
        display: inline-flex;
        align-items: center;
        gap: 6px;
        padding: 6px 10px;
        border-radius: 999px;
        border: 1px solid rgba(148, 163, 184, 0.2);
        background: rgba(15, 23, 42, 0.55);
      }

      .chip {
        width: 12px;
        height: 12px;
        border-radius: 50%;
      }

      .comparison-matrix {
        margin-top: 24px;
        overflow-x: auto;
      }

      .capability-grid {
        width: 100%;
        border-collapse: collapse;
        min-width: 540px;
      }

      .capability-grid th,
      .capability-grid td {
        border: 1px solid rgba(148, 163, 184, 0.2);
        padding: 12px;
        text-align: left;
        font-size: 0.9rem;
      }

      .capability-grid th {
        background: rgba(15, 23, 42, 0.7);
      }

      .capability-grid td svg {
        width: 22px;
        height: 22px;
        vertical-align: middle;
      }

      .quiz {
        margin-top: 36px;
        padding: 26px;
        border-radius: var(--radius-md);
        border: 1px solid rgba(148, 163, 184, 0.18);
        background: rgba(15, 23, 42, 0.6);
      }

      .quiz h3 {
        margin-top: 0;
        margin-bottom: 14px;
      }

      .quiz-question {
        margin-bottom: 22px;
      }

      .quiz-options {
        display: grid;
        gap: 10px;
      }

      .quiz-options button {
        text-align: left;
        padding: 12px 14px;
        border-radius: var(--radius-sm);
        border: 1px solid rgba(148, 163, 184, 0.18);
        background: rgba(15, 23, 42, 0.55);
        color: var(--text);
        cursor: pointer;
        transition: transform 0.2s ease, border-color 0.2s ease;
      }

      .quiz-options button:hover {
        transform: translateY(-2px);
        border-color: rgba(56, 189, 248, 0.4);
      }

      .quiz-options button.correct {
        border-color: rgba(52, 211, 153, 0.6);
        background: rgba(52, 211, 153, 0.2);
      }

      .quiz-options button.incorrect {
        border-color: rgba(248, 113, 113, 0.6);
        background: rgba(248, 113, 113, 0.2);
      }

      .quiz-feedback {
        font-size: 0.85rem;
        margin-top: 8px;
        color: var(--text-muted);
      }

      footer {
        margin: 48px auto 0;
        max-width: 1100px;
        text-align: center;
        color: var(--text-muted);
        font-size: 0.85rem;
      }

      @media (max-width: 720px) {
        body {
          padding: 0 16px 100px;
        }

        header {
          padding: 28px 22px;
        }

        .module-nav {
          position: static;
          justify-content: center;
        }

        .module {
          padding: 24px;
        }

        .rag-controls {
          flex-direction: column;
          align-items: stretch;
        }

        .rag-controls button {
          justify-content: center;
        }
      }
    </style>
  </head>
  <body>
    <header>
      <h1>Generative AI Learning Studio</h1>
      <p>
        Explore the modern landscape of large language models through interactive visual
        explanations. Deep dive into core architectures, compare fine-tuning strategies like LoRA
        and QLoRA, and understand how agentic Retrieval-Augmented Generation systems expand beyond
        traditional pipelines.
      </p>
      <div class="hero-stats">
        <div class="stat-card">
          <strong>Architectures Decoded</strong>
          <span>Understand decoder-only, encoder-decoder, encoder-only, and expert routing LLMs.</span>
        </div>
        <div class="stat-card">
          <strong>Fine-Tuning Spectrum</strong>
          <span>Compare parameter-efficient strategies using dynamic cost/performance overlays.</span>
        </div>
        <div class="stat-card">
          <strong>Agentic RAG Playbook</strong>
          <span>Simulate flows to see how orchestration, tools, and memory extend classic RAG.</span>
        </div>
      </div>
    </header>

    <main>
      <nav class="module-nav" aria-label="Module navigation">
        <button type="button" data-target="architectures" class="active">LLM Architectures</button>
        <button type="button" data-target="fine-tuning">Fine-Tuning Methods</button>
        <button type="button" data-target="rag">Standard vs Agentic RAG</button>
        <button type="button" data-target="quiz">Quick Knowledge Check</button>
      </nav>

      <section id="architectures" class="module" aria-labelledby="architectures-heading">
        <h2 id="architectures-heading">Core LLM Types &amp; Architectures</h2>
        <p class="module-intro">
          Navigate foundational architectural families, see how information flows through each
          network, and uncover the capabilities and trade-offs that make them suited for different
          tasks. Select a model class below to populate comparative insights and diagrams.
        </p>

        <div class="module-grid">
          <div class="panel">
            <h3>Architecture Explorer</h3>
            <p>Select an architecture to populate the interactive workspace.</p>
            <div class="pill-group" id="architecture-buttons" role="tablist"></div>

            <div class="stat-bars" id="architecture-bars"></div>
          </div>

          <div class="panel">
            <article id="architecture-content" role="tabpanel" aria-live="polite"></article>
          </div>
        </div>
      </section>

      <section id="fine-tuning" class="module" aria-labelledby="fine-tuning-heading">
        <h2 id="fine-tuning-heading">LLM Fine-Tuning Methodologies</h2>
        <p class="module-intro">
          Move along the spectrum from full model adaptation to lightweight low-rank updates. Use
          the slider to compare parameter efficiency, hardware needs, and resulting capability
          uplift across modern approaches such as LoRA and QLoRA.
        </p>

        <div class="panel">
          <h3>Method Selector</h3>
          <p>Position the slider to explore how each technique balances compute cost and agility.</p>
          <div class="range-wrapper">
            <input type="range" min="0" max="3" step="1" value="1" id="finetune-range" />
          </div>
          <div class="range-labels" aria-hidden="true">
            <span>Full Fine-Tune</span>
            <span>LoRA</span>
            <span>QLoRA</span>
            <span>Prompt Tuning</span>
          </div>

          <article id="finetune-content" aria-live="polite"></article>

          <table class="matrix" id="finetune-matrix" aria-label="Fine-tuning comparison matrix"></table>

          <div class="diagram-grid" id="finetune-diagrams"></div>

          <div class="method-cards" id="method-cards"></div>
        </div>
      </section>

      <section id="rag" class="module" aria-labelledby="rag-heading">
        <h2 id="rag-heading">Standard RAG vs Agentic RAG Systems</h2>
        <p class="module-intro">
          Observe how classic retrieval pipelines contrast with agentic orchestration. Interact with
          the stepper to animate information flow, expose decision points, and see how tools,
          planning, and memory enable deeper reasoning loops.
        </p>

        <div class="rag-comparison">
          <div class="rag-column" data-label="Standard RAG">
            <h3>Standard RAG Pipeline</h3>
            <ol class="rag-steps" id="rag-standard"></ol>
            <div class="rag-visual" id="rag-standard-visual"></div>
          </div>
          <div class="rag-column" data-label="Agentic RAG">
            <h3>Agentic RAG Pipeline</h3>
            <ol class="rag-steps" id="rag-agentic"></ol>
            <div class="rag-visual" id="rag-agentic-visual"></div>
          </div>
        </div>

        <div class="rag-controls">
          <button type="button" id="rag-play">
            <span aria-hidden="true">▶</span>
            Animate Flow Comparison
          </button>
          <div class="legend">
            <span><span class="chip" style="background: var(--accent)"></span> Retrieval</span>
            <span><span class="chip" style="background: #f472b6"></span> Planning / Orchestration</span>
            <span><span class="chip" style="background: #34d399"></span> Tool Calls</span>
            <span><span class="chip" style="background: #fbbf24"></span> Memory / Feedback</span>
          </div>
        </div>

        <div class="comparison-matrix">
          <table class="capability-grid" aria-label="Capabilities comparison between standard and agentic RAG"></table>
        </div>
      </section>

      <section id="quiz" class="module" aria-labelledby="quiz-heading">
        <h2 id="quiz-heading">Quick Knowledge Check</h2>
        <p class="module-intro">
          Reinforce key concepts with rapid questions. Each answer provides immediate feedback and a
          contextual explanation.
        </p>

        <div class="quiz" id="quiz-container"></div>
      </section>
    </main>

    <footer>
      Crafted as an interactive primer on generative AI systems — revisit modules anytime to
      reinforce understanding.
    </footer>

    <script>
      const architectureData = [
        {
          id: "decoder",
          name: "Autoregressive Decoder-Only",
          headline: "Generates tokens sequentially by predicting the next token from context.",
          summary:
            "Transformer decoder blocks stack self-attention and feed-forward layers, enabling long-range context modeling with causal masking. Ideal for generative tasks from code completion to creative writing.",
          strengths: [
            "Excellent at free-form generation and continuation tasks.",
            "Supports extremely large context windows with architectures like GPT-4 Turbo.",
            "Scales well with compute thanks to simple autoregressive objective.",
          ],
          considerations: [
            "No inherent bidirectional understanding; requires prompt engineering for conditioning.",
            "Training cost grows quickly with parameter count and context window.",
            "Susceptible to exposure bias without careful sampling strategies.",
          ],
          stats: {
            fluency: 92,
            controllability: 68,
            efficiency: 70,
            adaptability: 80,
          },
          diagram: `
            <svg viewBox="0 0 520 140" xmlns="http://www.w3.org/2000/svg" role="img" aria-label="Autoregressive decoder-only diagram">
              <defs>
                <linearGradient id="tok" x1="0" x2="1" y1="0" y2="1">
                  <stop stop-color="rgba(56,189,248,0.9)" offset="0" />
                  <stop stop-color="rgba(14,165,233,0.7)" offset="1" />
                </linearGradient>
                <linearGradient id="attn" x1="0" x2="0" y1="0" y2="1">
                  <stop stop-color="rgba(148,163,184,0.4)" offset="0" />
                  <stop stop-color="rgba(56,189,248,0.6)" offset="1" />
                </linearGradient>
              </defs>
              <g font-family="Inter" font-size="12" fill="currentColor">
                <rect x="20" y="20" width="80" height="36" rx="10" fill="url(#tok)" opacity="0.5" />
                <text x="60" y="43" text-anchor="middle">Token t-2</text>
                <rect x="140" y="20" width="80" height="36" rx="10" fill="url(#tok)" opacity="0.7" />
                <text x="180" y="43" text-anchor="middle">Token t-1</text>
                <rect x="260" y="20" width="80" height="36" rx="10" fill="url(#tok)" />
                <text x="300" y="43" text-anchor="middle">Token t</text>
                <rect x="380" y="20" width="100" height="36" rx="10" fill="rgba(15,23,42,0.8)" stroke="rgba(56,189,248,0.6)" />
                <text x="430" y="43" text-anchor="middle">Token t+1</text>
                <rect x="70" y="80" width="360" height="46" rx="16" fill="url(#attn)" stroke="rgba(56,189,248,0.4)" />
                <text x="250" y="108" text-anchor="middle">Self-Attention with causal mask</text>
                <path d="M100 56 L140 80" stroke="rgba(56,189,248,0.5)" stroke-width="3" stroke-linecap="round" />
                <path d="M220 56 L260 80" stroke="rgba(56,189,248,0.5)" stroke-width="3" stroke-linecap="round" />
                <path d="M340 56 L380 80" stroke="rgba(56,189,248,0.8)" stroke-width="3" stroke-linecap="round" />
              </g>
            </svg>
          `,
        },
        {
          id: "encoder-decoder",
          name: "Encoder-Decoder (Seq2Seq)",
          headline: "Uses paired encoders and decoders to translate representations into outputs.",
          summary:
            "Input tokens are bidirectionally encoded, creating context-rich vectors that condition a decoder. Widely used in translation, summarization, and instruction tuning where alignment between input and output is critical.",
          strengths: [
            "Encodes full input bidirectionally while decoding autoregressively for rich context.",
            "Natural fit for transduction tasks (summaries, translation, guided reasoning).",
            "Supports cross-attention, enabling controllable conditioning on structured inputs.",
          ],
          considerations: [
            "Dual stacks increase parameter count and latency.",
            "Requires well-aligned parallel data for optimal performance.",
            "Cross-attention can bottleneck for very long inputs without chunking strategies.",
          ],
          stats: {
            fluency: 85,
            controllability: 82,
            efficiency: 65,
            adaptability: 88,
          },
          diagram: `
            <svg viewBox="0 0 520 160" xmlns="http://www.w3.org/2000/svg" role="img" aria-label="Encoder-decoder architecture diagram">
              <defs>
                <linearGradient id="enc" x1="0" x2="1" y1="1" y2="0">
                  <stop stop-color="rgba(248,113,113,0.65)" offset="0" />
                  <stop stop-color="rgba(236,72,153,0.75)" offset="1" />
                </linearGradient>
                <linearGradient id="dec" x1="0" x2="1" y1="0" y2="1">
                  <stop stop-color="rgba(56,189,248,0.7)" offset="0" />
                  <stop stop-color="rgba(59,130,246,0.75)" offset="1" />
                </linearGradient>
              </defs>
              <g font-family="Inter" font-size="12" fill="currentColor">
                <rect x="30" y="20" width="160" height="40" rx="12" fill="url(#enc)" />
                <text x="110" y="45" text-anchor="middle">Encoder (bidirectional)</text>
                <rect x="330" y="20" width="160" height="40" rx="12" fill="url(#dec)" />
                <text x="410" y="45" text-anchor="middle">Decoder (autoregressive)</text>
                <rect x="230" y="20" width="80" height="40" rx="12" fill="rgba(15,23,42,0.8)" stroke="rgba(148,163,184,0.4)" />
                <text x="270" y="45" text-anchor="middle">Bridge</text>
                <path d="M190 40 C230 70, 230 70, 270 40" stroke="rgba(236,72,153,0.7)" stroke-width="4" fill="none" stroke-linecap="round" />
                <path d="M310 40 C350 70, 350 70, 390 40" stroke="rgba(56,189,248,0.7)" stroke-width="4" fill="none" stroke-linecap="round" />
                <rect x="60" y="90" width="100" height="40" rx="12" fill="rgba(236,72,153,0.35)" />
                <text x="110" y="115" text-anchor="middle">Input Tokens</text>
                <rect x="360" y="90" width="100" height="40" rx="12" fill="rgba(59,130,246,0.35)" />
                <text x="410" y="115" text-anchor="middle">Output Tokens</text>
                <path d="M110 130 L110 60" stroke="rgba(236,72,153,0.55)" stroke-width="3" stroke-dasharray="6 6" />
                <path d="M410 130 L410 60" stroke="rgba(59,130,246,0.55)" stroke-width="3" stroke-dasharray="6 6" />
              </g>
            </svg>
          `,
        },
        {
          id: "encoder",
          name: "Encoder-Only (Bidirectional)",
          headline: "Learns contextual embeddings for understanding and retrieval tasks.",
          summary:
            "Stacked transformer encoders attend bidirectionally to learn dense semantic representations. Powers sentence embedding models, retrieval pipelines, and hybrid systems that condition downstream generators.",
          strengths: [
            "Excels at semantic search, retrieval, and classification with pooled embeddings.",
            "Efficient inference with single forward pass and vector output.",
            "Pairs well with retrieval augmented and hybrid systems for grounding.",
          ],
          considerations: [
            "Not inherently generative; requires pairing with decoders for text outputs.",
            "Quality depends on pretraining objectives like MLM or contrastive learning.",
            "Limited long-form reasoning without external augmentation.",
          ],
          stats: {
            fluency: 40,
            controllability: 75,
            efficiency: 88,
            adaptability: 72,
          },
          diagram: `
            <svg viewBox="0 0 520 150" xmlns="http://www.w3.org/2000/svg" role="img" aria-label="Encoder-only architecture diagram">
              <defs>
                <linearGradient id="encOnly" x1="0" x2="1" y1="0" y2="1">
                  <stop stop-color="rgba(147,197,253,0.7)" offset="0" />
                  <stop stop-color="rgba(96,165,250,0.8)" offset="1" />
                </linearGradient>
              </defs>
              <g font-family="Inter" font-size="12" fill="currentColor">
                <rect x="40" y="28" width="120" height="36" rx="10" fill="rgba(96,165,250,0.3)" />
                <text x="100" y="50" text-anchor="middle">Tokens</text>
                <rect x="200" y="20" width="120" height="52" rx="16" fill="url(#encOnly)" />
                <text x="260" y="47" text-anchor="middle">Transformer Encoder</text>
                <rect x="360" y="28" width="120" height="36" rx="10" fill="rgba(148,163,184,0.4)" />
                <text x="420" y="50" text-anchor="middle">Embeddings</text>
                <path d="M160 46 L200 46" stroke="rgba(96,165,250,0.7)" stroke-width="4" stroke-linecap="round" />
                <path d="M320 46 L360 46" stroke="rgba(96,165,250,0.7)" stroke-width="4" stroke-linecap="round" />
                <rect x="200" y="92" width="120" height="40" rx="14" fill="rgba(15,23,42,0.8)" stroke="rgba(96,165,250,0.4)" />
                <text x="260" y="117" text-anchor="middle">Bidirectional self-attention</text>
              </g>
            </svg>
          `,
        },
        {
          id: "moe",
          name: "Mixture-of-Experts (Sparse)",
          headline: "Routes tokens through specialist expert blocks for efficiency at scale.",
          summary:
            "A gating network activates a sparse subset of expert feed-forward networks per token, boosting parameter count without proportional compute. Enables scaling to trillion-parameter regimes with manageable cost.",
          strengths: [
            "Massive parameter capacity with limited per-token computation.",
            "Dynamic routing encourages specialization across experts.",
            "Improves multi-domain performance and multilingual generalization.",
          ],
          considerations: [
            "Routing stability requires load-balancing losses and careful training.",
            "Serving infrastructure must support sharded expert placement.",
            "Debugging behavior becomes complex due to emergent specialization.",
          ],
          stats: {
            fluency: 90,
            controllability: 74,
            efficiency: 82,
            adaptability: 92,
          },
          diagram: `
            <svg viewBox="0 0 520 170" xmlns="http://www.w3.org/2000/svg" role="img" aria-label="Mixture-of-experts architecture diagram">
              <defs>
                <linearGradient id="gate" x1="0" x2="1" y1="0" y2="1">
                  <stop stop-color="rgba(45,212,191,0.7)" offset="0" />
                  <stop stop-color="rgba(16,185,129,0.7)" offset="1" />
                </linearGradient>
                <linearGradient id="expert" x1="0" x2="1" y1="1" y2="0">
                  <stop stop-color="rgba(56,189,248,0.4)" offset="0" />
                  <stop stop-color="rgba(129,140,248,0.7)" offset="1" />
                </linearGradient>
              </defs>
              <g font-family="Inter" font-size="12" fill="currentColor">
                <rect x="36" y="30" width="100" height="40" rx="12" fill="rgba(129,140,248,0.3)" />
                <text x="86" y="54" text-anchor="middle">Tokens</text>
                <rect x="166" y="24" width="120" height="52" rx="16" fill="url(#gate)" />
                <text x="226" y="52" text-anchor="middle">Routing / Gating</text>
                <g fill="url(#expert)">
                  <rect x="320" y="20" width="160" height="36" rx="12" opacity="0.65" />
                  <rect x="320" y="64" width="160" height="36" rx="12" opacity="0.8" />
                  <rect x="320" y="108" width="160" height="36" rx="12" opacity="0.65" />
                </g>
                <text x="400" y="44" text-anchor="middle">Expert 1</text>
                <text x="400" y="88" text-anchor="middle">Expert 2</text>
                <text x="400" y="132" text-anchor="middle">Expert N</text>
                <path d="M136 50 L166 50" stroke="rgba(129,140,248,0.7)" stroke-width="4" stroke-linecap="round" />
                <path d="M286 50 L320 38" stroke="rgba(56,189,248,0.7)" stroke-width="4" stroke-linecap="round" />
                <path d="M286 50 L320 82" stroke="rgba(16,185,129,0.7)" stroke-width="4" stroke-linecap="round" />
                <path d="M286 50 L320 124" stroke="rgba(129,140,248,0.7)" stroke-width="4" stroke-linecap="round" stroke-dasharray="5 6" />
              </g>
            </svg>
          `,
        },
      ];

      const statLabels = {
        fluency: "Generative Fluency",
        controllability: "Conditioning Control",
        efficiency: "Serving Efficiency",
        adaptability: "Task Adaptability",
      };

      const fineTuneMethods = [
        {
          id: "full-ft",
          name: "Full Fine-Tuning",
          tagline: "Update every parameter for maximum adaptability.",
          sliderIndex: 0,
          description:
            "Requires replicating the entire model on accelerator memory. Offers maximal control but demands significant compute budgets and careful regularization to prevent catastrophic forgetting.",
          metrics: {
            parametersTouched: "100%",
            memoryFootprint: "High (e.g., 8×A100 80GB)",
            latencyImpact: "Moderate",
            bestFor: "Domain-specialized models at scale",
          },
          diagram: `
            <svg viewBox="0 0 220 140" xmlns="http://www.w3.org/2000/svg" role="img" aria-label="Full fine-tuning diagram">
              <rect x="20" y="20" width="180" height="100" rx="18" fill="rgba(56,189,248,0.18)" stroke="rgba(56,189,248,0.6)" stroke-width="2" />
              <text x="110" y="50" text-anchor="middle" font-size="12" fill="currentColor">Model</text>
              <text x="110" y="70" text-anchor="middle" font-size="12" fill="currentColor">Parameters</text>
              <text x="110" y="95" text-anchor="middle" font-size="11" fill="rgba(148,163,184,0.9)">All weights updated</text>
            </svg>
          `,
          card: "Best when you can afford full retraining and need maximum domain adaptation.",
        },
        {
          id: "lora",
          name: "LoRA",
          tagline: "Inject low-rank adapters inside attention projections.",
          sliderIndex: 1,
          description:
            "Learns delta matrices of low rank that are merged during inference. Dramatically reduces trainable parameters, enabling rapid experiments while keeping base weights frozen.",
          metrics: {
            parametersTouched: "0.1–2%",
            memoryFootprint: "Medium (fits on prosumer GPUs)",
            latencyImpact: "Low",
            bestFor: "Task-specific instruction tuning",
          },
          diagram: `
            <svg viewBox="0 0 220 140" xmlns="http://www.w3.org/2000/svg" role="img" aria-label="LoRA diagram">
              <rect x="20" y="20" width="180" height="100" rx="18" fill="rgba(56,189,248,0.12)" stroke="rgba(56,189,248,0.35)" />
              <rect x="40" y="40" width="140" height="60" rx="14" fill="rgba(14,165,233,0.2)" />
              <rect x="70" y="52" width="80" height="36" rx="10" fill="rgba(56,189,248,0.5)" />
              <text x="110" y="74" text-anchor="middle" font-size="11" fill="currentColor">Low-Rank ΔW</text>
              <text x="110" y="106" text-anchor="middle" font-size="10" fill="rgba(148,163,184,0.9)">Adapters merged at inference</text>
            </svg>
          `,
          card:
            "Reusable adapters allow rapid context switching between domains while sharing a frozen base model.",
        },
        {
          id: "qlora",
          name: "QLoRA",
          tagline: "Quantize base weights and train rank adapters in FP16/8.",
          sliderIndex: 2,
          description:
            "Applies 4-bit NF4 quantization to the frozen backbone and trains LoRA adapters on higher precision. Unlocks fine-tuning of 65B parameter models on a single 48GB GPU without large quality drops.",
          metrics: {
            parametersTouched: "≈0.1%",
            memoryFootprint: "Low (single GPU friendly)",
            latencyImpact: "Low",
            bestFor: "Cost-sensitive adaptation with large models",
          },
          diagram: `
            <svg viewBox="0 0 220 140" xmlns="http://www.w3.org/2000/svg" role="img" aria-label="QLoRA diagram">
              <rect x="20" y="20" width="180" height="100" rx="18" fill="rgba(99,102,241,0.18)" stroke="rgba(99,102,241,0.45)" />
              <rect x="30" y="32" width="160" height="48" rx="14" fill="rgba(30,41,59,0.8)" stroke="rgba(148,163,184,0.25)" />
              <text x="110" y="60" text-anchor="middle" font-size="11" fill="rgba(148,163,184,0.9)">NF4 Quantized Base</text>
              <rect x="50" y="90" width="120" height="20" rx="8" fill="rgba(16,185,129,0.4)" />
              <text x="110" y="105" text-anchor="middle" font-size="10" fill="currentColor">LoRA ΔW in higher precision</text>
            </svg>
          `,
          card:
            "Balances quality and affordability — ideal for community fine-tunes and iterative experimentation.",
        },
        {
          id: "prompt-tuning",
          name: "Prompt Tuning / P-Tuning v2",
          tagline: "Learn soft prompts prepended to inputs.",
          sliderIndex: 3,
          description:
            "Optimizes a small set of virtual prompt tokens that steer model behavior without modifying core weights. Extremely lightweight yet surprisingly effective for narrow tasks.",
          metrics: {
            parametersTouched: "<0.01%",
            memoryFootprint: "Very low",
            latencyImpact: "Minimal",
            bestFor: "Rapid adaptation &amp; inference-time routing",
          },
          diagram: `
            <svg viewBox="0 0 220 140" xmlns="http://www.w3.org/2000/svg" role="img" aria-label="Prompt tuning diagram">
              <rect x="20" y="20" width="180" height="100" rx="18" fill="rgba(248,113,113,0.15)" stroke="rgba(248,113,113,0.4)" />
              <rect x="30" y="32" width="60" height="76" rx="12" fill="rgba(248,113,113,0.5)" />
              <text x="60" y="72" text-anchor="middle" font-size="11" fill="currentColor">Soft</text>
              <text x="60" y="88" text-anchor="middle" font-size="11" fill="currentColor">Prompt</text>
              <rect x="110" y="32" width="90" height="76" rx="12" fill="rgba(56,189,248,0.25)" />
              <text x="155" y="72" text-anchor="middle" font-size="11" fill="currentColor">Frozen LLM</text>
            </svg>
          `,
          card:
            "Use for routing or personalization where latency and simplicity matter more than raw score gains.",
        },
      ];

      const fineTuneMatrixHeaders = [
        "Technique",
        "Trainable Parameters",
        "Hardware Demand",
        "Inference Overhead",
        "Ideal Scenarios",
      ];

      const ragPipelines = {
        standard: [
          {
            title: "User Query",
            detail: "Natural language input, often long-tail or under-specified.",
            color: "var(--accent)",
          },
          {
            title: "Embedding & Retrieval",
            detail: "Vector search surfaces top-k passages from indexed corpus.",
            color: "var(--accent)",
          },
          {
            title: "Augmented Prompt",
            detail: "Snippets concatenated with query to ground generation.",
            color: "var(--accent)",
          },
          {
            title: "Generate Response",
            detail: "LLM produces answer conditioned on retrieved context.",
            color: "var(--accent)",
          },
        ],
        agentic: [
          {
            title: "Goal Decomposition",
            detail: "Planner expands query into actionable subtasks.",
            color: "#f472b6",
          },
          {
            title: "Dynamic Retrieval",
            detail: "Multiple retrieval rounds with adaptive query rewriting.",
            color: "var(--accent)",
          },
          {
            title: "Tool & API Calls",
            detail: "Agents invoke calculators, search, or structured APIs when needed.",
            color: "#34d399",
          },
          {
            title: "Memory Consolidation",
            detail: "Intermediate results stored for reuse and reflection.",
            color: "#fbbf24",
          },
          {
            title: "Response Synthesis",
            detail: "Orchestrator composes final answer using verified evidence.",
            color: "#f472b6",
          },
        ],
      };

      const ragCapabilities = [
        {
          dimension: "Handles multi-hop reasoning",
          standard: false,
          agentic: true,
          insight: "Agents chain retrieval and tool calls, iterating until confidence threshold is achieved.",
        },
        {
          dimension: "Dynamic tool invocation",
          standard: false,
          agentic: true,
          insight: "Toolformer-style policies or planners decide when calculators, web search, or APIs should run.",
        },
        {
          dimension: "Deterministic grounding",
          standard: true,
          agentic: true,
          insight: "Both rely on retrieved passages but agentic systems can re-query to close gaps.",
        },
        {
          dimension: "Feedback loop & memory",
          standard: "Limited",
          agentic: true,
          insight: "Agent memories capture intermediate findings so later steps don’t repeat effort.",
        },
        {
          dimension: "Latency sensitivity",
          standard: "Low latency",
          agentic: "Higher but configurable",
          insight: "Agentic flows trade latency for deeper reasoning via orchestration.",
        },
      ];

      const quizQuestions = [
        {
          prompt: "What makes QLoRA especially attractive for community fine-tuning?",
          options: [
            "It updates all base parameters for maximal accuracy.",
            "It reduces memory needs via quantization while learning low-rank adapters.",
            "It trains only a prompt so there is virtually no compute cost.",
          ],
          answer: 1,
          explanation:
            "QLoRA freezes the backbone in 4-bit precision and optimizes lightweight adapters, enabling large models on modest GPUs.",
        },
        {
          prompt: "Why do agentic RAG systems excel at multi-hop questions?",
          options: [
            "They rely on single-pass retrieval with fixed top-k results.",
            "Agents can plan, iterate, and call tools/memory to incrementally build answers.",
            "They use encoder-only transformers which have stronger embeddings.",
          ],
          answer: 1,
          explanation:
            "Agentic RAG orchestrates multiple steps—planning, tool use, and reflection—until the goal is satisfied.",
        },
        {
          prompt: "Which architecture is best suited for semantic retrieval embedding models?",
          options: [
            "Decoder-only transformers",
            "Encoder-only transformers",
            "Mixture-of-experts decoders",
          ],
          answer: 1,
          explanation:
            "Encoder-only (bidirectional) models excel at producing dense embeddings for retrieval and classification.",
        },
      ];

      const architectureButtonsContainer = document.getElementById("architecture-buttons");
      const architectureContent = document.getElementById("architecture-content");
      const architectureBars = document.getElementById("architecture-bars");

      function renderArchitectureButtons() {
        architectureButtonsContainer.innerHTML = "";
        architectureData.forEach((arch, index) => {
          const button = document.createElement("button");
          button.className = `pill ${index === 0 ? "active" : ""}`;
          button.type = "button";
          button.textContent = arch.name;
          button.dataset.architecture = arch.id;
          button.setAttribute("role", "tab");
          architectureButtonsContainer.appendChild(button);
        });
      }

      function renderArchitectureStats(activeArch) {
        architectureBars.innerHTML = "";
        Object.entries(statLabels).forEach(([key, label]) => {
          const wrapper = document.createElement("div");
          wrapper.className = "stat-bar";

          const labelEl = document.createElement("span");
          labelEl.textContent = `${label} (${activeArch.stats[key]}%)`;

          const track = document.createElement("div");
          track.className = "bar-track";

          const fill = document.createElement("div");
          fill.className = "bar-fill";
          fill.style.width = `${activeArch.stats[key]}%`;

          track.appendChild(fill);
          wrapper.append(labelEl, track);
          architectureBars.appendChild(wrapper);
        });
      }

      function renderArchitectureContent(activeArch) {
        architectureContent.innerHTML = `
          <header>
            <h3>${activeArch.name}</h3>
            <p>${activeArch.headline}</p>
          </header>
          <p>${activeArch.summary}</p>
          <div class="architecture-diagram">${activeArch.diagram}</div>
          <div class="list-grid">
            <div>
              <h4>Strengths</h4>
              <ul>
                ${activeArch.strengths.map((item) => `<li>${item}</li>`).join("")}
              </ul>
            </div>
            <div>
              <h4>Considerations</h4>
              <ul>
                ${activeArch.considerations.map((item) => `<li>${item}</li>`).join("")}
              </ul>
            </div>
          </div>
        `;
      }

      function handleArchitectureChange(event) {
        const target = event.target.closest(".pill");
        if (!target) return;
        const selected = architectureData.find((arch) => arch.id === target.dataset.architecture);
        if (!selected) return;

        architectureButtonsContainer.querySelectorAll(".pill").forEach((pill) => {
          pill.classList.toggle("active", pill === target);
        });

        renderArchitectureStats(selected);
        renderArchitectureContent(selected);
      }

      architectureButtonsContainer.addEventListener("click", handleArchitectureChange);

      renderArchitectureButtons();
      renderArchitectureStats(architectureData[0]);
      renderArchitectureContent(architectureData[0]);

      const finetuneRange = document.getElementById("finetune-range");
      const finetuneContent = document.getElementById("finetune-content");
      const finetuneMatrix = document.getElementById("finetune-matrix");
      const finetuneDiagrams = document.getElementById("finetune-diagrams");
      const methodCards = document.getElementById("method-cards");

      function renderFineTuneMatrix(activeId) {
        const rows = fineTuneMethods.map((method) => `
          <tr>
            <td>${method.name}</td>
            <td>${method.metrics.parametersTouched}</td>
            <td>${method.metrics.memoryFootprint}</td>
            <td>${method.metrics.latencyImpact}</td>
            <td>${method.metrics.bestFor}</td>
          </tr>
        `);

        finetuneMatrix.innerHTML = `
          <thead>
            <tr>${fineTuneMatrixHeaders.map((header) => `<th>${header}</th>`).join("")}</tr>
          </thead>
          <tbody>
            ${rows
              .map((row, index) =>
                row.replace(
                  "<tr>",
                  `<tr class="${fineTuneMethods[index].id === activeId ? "active-row" : ""}">`
                )
              )
              .join("")}
          </tbody>
        `;

        Array.from(finetuneMatrix.querySelectorAll("tbody tr")).forEach((row, index) => {
          row.querySelectorAll("td").forEach((cell) => {
            cell.classList.toggle("highlight", fineTuneMethods[index].id === activeId);
          });
        });
      }

      function renderFineTuneContent(method) {
        finetuneContent.innerHTML = `
          <h3>${method.name}</h3>
          <p>${method.tagline}</p>
          <p>${method.description}</p>
        `;

        finetuneDiagrams.innerHTML = method.diagram
          ? `<div class="diagram-card">${method.diagram}</div>`
          : "";
      }

      function renderMethodCards(activeId) {
        methodCards.innerHTML = "";
        fineTuneMethods.forEach((method) => {
          const card = document.createElement("article");
          card.className = `method-card ${method.id === activeId ? "active" : ""}`;
          card.innerHTML = `
            <div class="badge">${method.metrics.parametersTouched} params</div>
            <h4>${method.name}</h4>
            <p>${method.card}</p>
          `;
          methodCards.appendChild(card);
        });
      }

      function updateFineTuneView(index) {
        const selected = fineTuneMethods.find((method) => method.sliderIndex === index);
        if (!selected) return;
        renderFineTuneContent(selected);
        renderFineTuneMatrix(selected.id);
        renderMethodCards(selected.id);
      }

      finetuneRange.addEventListener("input", (event) => {
        updateFineTuneView(Number(event.target.value));
      });

      updateFineTuneView(Number(finetuneRange.value));

      const ragStandardList = document.getElementById("rag-standard");
      const ragAgenticList = document.getElementById("rag-agentic");
      const ragStandardVisual = document.getElementById("rag-standard-visual");
      const ragAgenticVisual = document.getElementById("rag-agentic-visual");
      const ragPlayButton = document.getElementById("rag-play");
      const capabilityGrid = document.querySelector(".capability-grid");

      function makePipelineList(listEl, steps, group) {
        listEl.innerHTML = "";
        steps.forEach((step, index) => {
          const item = document.createElement("li");
          item.dataset.step = index + 1;
          item.innerHTML = `<strong>${step.title}</strong><br /><span>${step.detail}</span>`;
          item.style.setProperty("--step-color", step.color);
          item.addEventListener("mouseenter", () => highlightStep(group, index));
          item.addEventListener("focus", () => highlightStep(group, index));
          listEl.appendChild(item);
        });
      }

      function buildPipelineDiagram(steps, title) {
        const height = 80 + steps.length * 32;
        const stepHeight = 32;
        let circles = "";
        let connectors = "";
        steps.forEach((step, index) => {
          const y = 40 + index * stepHeight;
          circles += `<circle cx="70" cy="${y}" r="14" fill="${step.color}" opacity="0.9" />`;
          circles += `<text x="70" y="${y + 4}" text-anchor="middle" font-size="11" fill="rgba(15,23,42,0.9)">${index + 1}</text>`;
          circles += `<rect x="110" y="${y - 14}" width="240" height="28" rx="10" fill="rgba(148,163,184,0.2)" stroke="${step.color}" stroke-width="1.5" />`;
          circles += `<text x="230" y="${y + 3}" text-anchor="middle" font-size="11" fill="currentColor">${step.title}</text>`;
          if (index < steps.length - 1) {
            const nextY = 40 + (index + 1) * stepHeight;
            connectors += `<line x1="70" y1="${y + 14}" x2="70" y2="${nextY - 14}" stroke="${step.color}" stroke-width="3" stroke-linecap="round" />`;
          }
        });

        return `
          <svg viewBox="0 0 380 ${height}" xmlns="http://www.w3.org/2000/svg" role="img" aria-label="${title}">
            <title>${title}</title>
            <g font-family="Inter" fill="currentColor">
              ${connectors}
              ${circles}
            </g>
          </svg>
        `;
      }

      function renderPipeline() {
        makePipelineList(ragStandardList, ragPipelines.standard, "standard");
        makePipelineList(ragAgenticList, ragPipelines.agentic, "agentic");
        ragStandardVisual.innerHTML = buildPipelineDiagram(ragPipelines.standard, "Standard RAG flow");
        ragAgenticVisual.innerHTML = buildPipelineDiagram(ragPipelines.agentic, "Agentic RAG flow");
      }

      function renderCapabilityGrid() {
        capabilityGrid.innerHTML = `
          <thead>
            <tr>
              <th>Capability Dimension</th>
              <th>Standard RAG</th>
              <th>Agentic RAG</th>
              <th>Why it matters</th>
            </tr>
          </thead>
          <tbody>
            ${ragCapabilities
              .map((row) => {
                const icon = (value) => {
                  if (value === true)
                    return `<svg viewBox="0 0 20 20" fill="none" stroke="${"#34d399"}" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M4 10l3 3 9-9"/></svg>`;
                  if (value === false)
                    return `<svg viewBox="0 0 20 20" fill="none" stroke="${"#f87171"}" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M6 6l8 8M6 14l8-8"/></svg>`;
                  return `<span>${value}</span>`;
                };
                return `
                  <tr>
                    <td>${row.dimension}</td>
                    <td>${icon(row.standard)}</td>
                    <td>${icon(row.agentic)}</td>
                    <td>${row.insight}</td>
                  </tr>
                `;
              })
              .join("")}
          </tbody>
        `;
      }

      function highlightStep(group, index) {
        const list = group === "standard" ? ragStandardList : ragAgenticList;
        const otherList = group === "standard" ? ragAgenticList : ragStandardList;
        const steps = list.querySelectorAll("li");
        const otherSteps = otherList.querySelectorAll("li");

        steps.forEach((step, idx) => {
          step.classList.toggle("active", idx === index);
        });

        if (otherSteps[index]) {
          otherSteps.forEach((step, idx) => {
            step.classList.toggle("active", idx === index);
          });
        }
      }

      let animationInterval;

      function animatePipelines() {
        clearInterval(animationInterval);
        let stepIndex = 0;
        const maxSteps = Math.max(ragPipelines.standard.length, ragPipelines.agentic.length);

        highlightStep("standard", 0);

        animationInterval = setInterval(() => {
          stepIndex += 1;
          if (stepIndex >= maxSteps) {
            clearInterval(animationInterval);
            return;
          }
          highlightStep("standard", stepIndex);
        }, 1600);
      }

      ragPlayButton.addEventListener("click", animatePipelines);

      renderPipeline();
      renderCapabilityGrid();

      function renderQuiz() {
        const container = document.getElementById("quiz-container");
        container.innerHTML = "";

        quizQuestions.forEach((question, questionIndex) => {
          const wrapper = document.createElement("article");
          wrapper.className = "quiz-question";
          wrapper.innerHTML = `<h3>Question ${questionIndex + 1}</h3><p>${question.prompt}</p>`;

          const optionsWrapper = document.createElement("div");
          optionsWrapper.className = "quiz-options";

          const feedback = document.createElement("div");
          feedback.className = "quiz-feedback";

          question.options.forEach((option, optionIndex) => {
            const button = document.createElement("button");
            button.type = "button";
            button.textContent = option;
            button.addEventListener("click", () => {
              const isCorrect = optionIndex === question.answer;
              optionsWrapper.querySelectorAll("button").forEach((btn, idx) => {
                btn.disabled = true;
                btn.classList.remove("correct", "incorrect");
                btn.classList.add(idx === question.answer ? "correct" : idx === optionIndex ? "incorrect" : "");
              });
              feedback.textContent = question.explanation;
              feedback.style.color = isCorrect ? "var(--success)" : "var(--warning)";
            });
            optionsWrapper.appendChild(button);
          });

          wrapper.append(optionsWrapper, feedback);
          container.appendChild(wrapper);
        });
      }

      renderQuiz();

      const moduleNav = document.querySelector(".module-nav");
      moduleNav.addEventListener("click", (event) => {
        const button = event.target.closest("button[data-target]");
        if (!button) return;
        const target = document.getElementById(button.dataset.target);
        if (!target) return;
        target.scrollIntoView({ behavior: "smooth", block: "start" });

        moduleNav.querySelectorAll("button").forEach((btn) => {
          btn.classList.toggle("active", btn === button);
        });
      });

      const observer = new IntersectionObserver(
        (entries) => {
          entries.forEach((entry) => {
            if (entry.isIntersecting) {
              const id = entry.target.id;
              moduleNav.querySelectorAll("button").forEach((button) => {
                button.classList.toggle("active", button.dataset.target === id);
              });
            }
          });
        },
        { threshold: 0.35 }
      );

      document.querySelectorAll("section.module").forEach((section) => observer.observe(section));
    </script>
  </body>
</html>
